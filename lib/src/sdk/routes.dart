import '../session/session.dart';
import '../types/others.dart';
import '../types/responses.dart';
import '../types/user.dart';

/// General authentication functions
abstract class DescopeAuth {
  /// Returns details about the user.
  ///
  /// The user must have an active [DescopeSession] whose [refreshJwt] should be
  /// passed as a parameter to this function.
  Future<DescopeUser> me(String refreshJwt);

  /// Refreshes a [DescopeSession].
  ///
  /// This can be called at any time as long as the [refreshJwt] is still
  /// valid. Typically called when a [DescopeSession]'s [sessionJwt] is expired
  /// or is about expire.
  Future<RefreshResponse> refreshSession(String refreshJwt);

  /// Logs out from an active [DescopeSession].
  Future<void> logout(String refreshJwt);
}

/// Authenticate users using a one time password (OTP) code, sent via
/// a delivery method of choice. The code then needs to be verified using
/// the [verify] function. It is also possible to add an email or phone to
/// an existing user after validating it via OTP.
abstract class DescopeOtp {
  /// Authenticates a new user using an OTP
  ///
  /// The OTP code will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  /// - Important: Make sure the delivery information corresponding with
  ///     the delivery [method] is given either in the optional [details] parameter or as
  ///     the [loginId] itself, i.e., the email address, phone number, etc.
  Future<String> signUp({required DeliveryMethod method, required String loginId, SignUpDetails? details});

  /// Authenticates an existing user using an OTP
  ///
  /// The OTP code will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  Future<String> signIn({required DeliveryMethod method, required String loginId});

  /// Authenticates an existing user if one exists, or creates a new user
  /// using an OTP
  ///
  /// The OTP code will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  /// - Important: Make sure the delivery information corresponding with
  ///     the delivery [method] is given either in the optional [user] parameter or as
  ///     the [loginId] itself, i.e., the email address, phone number, etc.
  Future<String> signUpOrIn({required DeliveryMethod method, required String loginId});

  /// Verifies an OTP [code] sent to the user.
  ///
  /// Provide this functions with the [loginId] and [method] of delivery used to
  /// send the [code]. Upon successful authentication an [AuthenticationResponse] is returned.
  Future<AuthenticationResponse> verify({required DeliveryMethod method, required String loginId, required String code});

  /// Updates an existing user by adding an email address.
  ///
  /// The [email] will be updated for the user identified by [loginId]
  /// after it is verified via OTP. In order to do this,
  /// the user must have an active [DescopeSession] whose [refreshJwt] should
  /// be passed as a parameter to this function.
  Future<String> updateEmail({required String email, required String loginId, required String refreshJwt});

  /// Updates an existing user by adding a phone number.
  ///
  /// The [phone] number will be updated for the user identified by [loginId]
  /// after it is verified via OTP. In order to do this,
  /// the user must have an active [DescopeSession] whose [refreshJwt] should
  /// be passed as a parameter to this function.
  ///
  /// - Important: Make sure delivery [method] is appropriate for using a phone number.
  Future<String> updatePhone({required String phone, required DeliveryMethod method, required String loginId, required String refreshJwt});
}

/// Authenticate users using Timed One-time Passwords (TOTP) codes.
///
/// This authentication method is geared towards using an authenticator app which
/// can produce TOTP codes.
abstract class DescopeTotp {
  /// Authenticates a new user using a TOTP.
  ///
  /// This function creates a new user identified by [loginId] and
  /// the optional information provided on via the [details] object.
  /// It returns a [TotpResponse.key] (seed) that allows
  /// authenticator apps to generate TOTP codes. The same information
  /// is returned in multiple formats.
  Future<TotpResponse> signUp({required String loginId, SignUpDetails? details});

  /// Updates an existing user by adding TOTP as an authentication method.
  ///
  /// In order to do this, the user identified by [loginId] must have an active
  /// [DescopeSession] whose [refreshJwt] should be passed as a parameter to this function.
  ///
  /// This function returns a [TotpResponse.key] (seed) that allows
  /// authenticator apps to generate TOTP codes. The same information
  /// is returned in multiple formats.
  Future<TotpResponse> update({required String loginId, required String refreshJwt});

  /// Verifies a TOTP code that was generated by an authenticator app.
  ///
  /// Returns an [AuthenticationResponse] if the provided [loginId] and the [code]
  /// generated by an authenticator app match.
  Future<AuthenticationResponse> verify({required String loginId, required String code});
}

/// Authenticate users using a password.
abstract class DescopePassword {
  /// Creates a new user that can later sign in with a password.
  ///
  /// Uses [loginId] to identify the user, typically an email, phone,
  /// or any other unique identifier. The provided [password] will allow
  /// the user to sign in in the future and must conform to the password policy
  /// defined in the password settings in the Descope console.
  /// The optional [details] provides additional details about the user signing up.
  /// Returns an [AuthenticationResponse] upon successful authentication.
  Future<AuthenticationResponse> signUp({required String loginId, required String password, SignUpDetails? details});

  /// Authenticates an existing user using a password.
  ///
  /// Matches the provided [loginId] and [password].
  /// Returns an [AuthenticationResponse] upon successful authentication.
  Future<AuthenticationResponse> signIn({required String loginId, required String password});

  /// Updates a user's password.
  ///
  /// In order to do this, the user must have an active [DescopeSession] whose
  /// [refreshJwt] should be passed as a parameter to this function.
  ///
  /// Updates the user identified by [loginId] with [newPassword].
  /// [newPassword] must conform to the password policy defined in the
  /// password settings in the Descope console
  Future<void> update({required String loginId, required String newPassword, required String refreshJwt});

  /// Replaces a user's password by providing their current password.
  ///
  /// Updates the user identified by [loginId] and [oldPassword] with [newPassword].
  /// [newPassword] must conform to the password policy defined in the
  /// password settings in the Descope console
  Future<void> replace({required String loginId, required String oldPassword, required String newPassword});

  /// Sends a password reset email to the user.
  ///
  /// This operation starts a Magic Link flow for the user identified by
  /// [loginId] depending on the configuration in the Descope console. An optional
  /// [redirectUrl] can be provided to the magic link method.
  /// After the authentication flow is finished
  /// use the [refreshJwt] to call [update] and change the user's password.
  ///
  /// - Important: The user must be verified according to the configured
  /// password reset method.
  Future<void> sendReset({required String loginId, String? redirectUrl});

  /// Fetches the rules for valid passwords.
  ///
  /// The [PasswordPolicy] is configured in the password settings in the Descope console, and
  /// these values can be used to implement client-side validation of new user passwords
  /// for a better user experience.
  ///
  /// In any case, all password rules are enforced by Descope on the server side as well.
  Future<PasswordPolicy> getPolicy();
}

/// Authenticate users using a special link that once clicked, can authenticate
/// the user.
///
/// In order to correctly implement, the app must make sure the link redirects back
/// to the app. Read more on [universal links](https://developer.apple.com/ios/universal-links/)
/// and [app links](https://developer.android.com/training/app-links)
/// to learn more. Once redirected back to the app, call the [verify] function
/// on the appended token URL parameter.
abstract class DescopeMagicLink {
  /// Authenticates a new user using a magic link.
  ///
  /// The magic link will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  /// - Important: Make sure the delivery information corresponding with
  ///     the delivery [method] is given either in the optional [details] parameter or as
  ///     the [loginId] itself, i.e., the email address, phone number, etc.
  ///
  /// - Important: Make sure a default magic link URI is configured
  ///     in the Descope console, or provided by this call via [uri].
  Future<String> signUp({required DeliveryMethod method, required String loginId, SignUpDetails? details, String? uri});

  /// Authenticates an existing user using a magic link.
  ///
  /// The magic link will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  /// - Important: Make sure a default magic link URI is configured
  ///     in the Descope console, or provided by this call via [uri].
  Future<String> signIn({required DeliveryMethod method, required String loginId, String? uri});

  /// Authenticates an existing user if one exists, or creates a new user
  /// using a magic link.
  ///
  /// The magic link will be sent to the user identified by [loginId]
  /// via a delivery [method] of choice.
  /// - Important: Make sure the delivery information corresponding with
  ///     the delivery [method] is given either in the optional [user] parameter or as
  ///     the [loginId] itself, i.e., the email address, phone number, etc.
  ///
  /// - Important: Make sure a default magic link URI is configured
  ///     in the Descope console, or provided by this call via [uri].
  Future<String> signUpOrIn({required DeliveryMethod method, required String loginId, String? uri});

  /// Updates an existing user by adding an [email] address.
  ///
  /// The [email] will be updated for the user identified by [loginId]
  /// after it is verified via magic link. In order to do this,
  /// the user must have an active [DescopeSession] whose [refreshJwt] should
  /// be passed as a parameter to this function.
  ///
  /// - Important: Make sure a default magic link URI is configured
  ///     in the Descope console, or provided by this call via [uri].
  Future<String> updateEmail({required String email, required String loginId, String? uri, required String refreshJwt});

  /// Updates an existing user by adding a [phone] number.
  ///
  /// The [phone] number will be updated for the user identified by [loginId]
  /// after it is verified via magic link. In order to do this,
  /// the user must have an active [DescopeSession] whose [refreshJwt] should
  /// be passed as a parameter to this function.
  ///
  /// - Important: Make sure the delivery information corresponding with
  ///     the phone number enabled delivery [method].
  ///
  /// - Important: Make sure a default magic link URI is configured
  ///     in the Descope console, or provided by this call via [uri].
  Future<String> updatePhone({required String phone, required DeliveryMethod method, required String loginId, String? uri, required String refreshJwt});

  /// Verifies a magic link [token].
  ///
  /// In order to effectively do this, the link generated should refer back to
  /// the app, then the `t` URL parameter should be extracted and sent to this
  /// function. Upon successful authentication an [AuthenticationResponse] is returned.
  Future<AuthenticationResponse> verify({required String token});
}

/// Authenticate users using one of three special links that once clicked,
/// can authenticate the user.
///
/// This method is geared towards cross-device authentication. In order to
/// correctly implement, the app must make sure the uri redirects to a webpage
/// which will verify the link for them. The app will poll for a valid session
/// in the meantime, and will authenticate the user as soon as they are
/// verified via said webpage. To learn more consult the
/// official Descope docs.
abstract class DescopeEnchantedLink {
  /// Authenticates a new user using an enchanted link, sent via email.
  ///
  /// A new user identified by [loginId] and the optional [details] details will be added
  /// upon successful authentication.
  /// The caller should use the returned [EnchantedLinkResponse.linkId] to show the
  /// user which link they need to press in the enchanted link email, and then use
  /// the [EnchantedLinkResponse.pendingRef] value to poll until the authentication is verified.
  ///
  /// - Important: Make sure an email address is provided via
  ///     the [details] parameter or as the [loginId] itself.
  ///
  /// - Important: Make sure a default Enchanted link URI is configured
  ///     in the Descope console, or provided via [uri] by this call.
  Future<EnchantedLinkResponse> signUp({required String loginId, SignUpDetails? details, String? uri});

  /// Authenticates an existing user using an enchanted link, sent via email.
  ///
  /// An enchanted link will be sent to the user identified by [loginId].
  /// The caller should use the returned [EnchantedLinkResponse.linkId] to show the
  /// user which link they need to press in the enchanted link email, and then use
  /// the [EnchantedLinkResponse.pendingRef] value to poll until the authentication is verified.
  ///
  /// - Important: Make sure a default Enchanted link URI is configured
  ///     in the Descope console, or provided via [uri] by this call.
  Future<EnchantedLinkResponse> signIn({required String loginId, String? uri});

  /// Authenticates an existing user if one exists, or create a new user using an
  /// enchanted link, sent via email.
  ///
  /// The caller should use the returned [EnchantedLinkResponse.linkId] to show the
  /// user which link they need to press in the enchanted link email, and then use
  /// the [EnchantedLinkResponse.pendingRef] value to poll until the authentication is verified.
  ///
  /// - Important: Make sure a default Enchanted link URI is configured
  ///     in the Descope console, or provided via [uri] by this call.
  Future<EnchantedLinkResponse> signUpOrIn({required String loginId, String? uri});

  /// Updates an existing user by adding an email address.
  ///
  /// The [email] will be updated after it is verified via enchanted link. In order to
  /// do this, the user must have an active [DescopeSession] whose [refreshJwt] should
  /// be passed as a parameter to this function.
  ///
  /// The caller should use the returned [EnchantedLinkResponse.linkId] to show the
  /// user which link they need to press in the enchanted link email, and then use
  /// the [EnchantedLinkResponse.pendingRef] value to poll until the authentication is verified.
  Future<EnchantedLinkResponse> updateEmail({required String email, required String loginId, String? uri, required String refreshJwt});

  /// Checks if an enchanted link authentication has been verified by the user.
  ///
  /// Provide this function with a [pendingRef] received by [signUp], [signIn], [signUpOrIn] or [updateEmail].
  /// This function will only return an [AuthenticationResponse] successfully after the user
  /// presses the enchanted link in the authentication email.
  ///
  /// - Important: This function doesn't perform any polling or waiting, so calling code
  ///     should expect to catch any thrown exceptions and
  ///     handle them appropriately. For most use cases it might be more convenient to
  ///     use [pollForSession] instead.
  Future<AuthenticationResponse> checkForSession({required String pendingRef});

  /// Waits until an enchanted link authentication has been verified by the user.
  ///
  /// Provide this function with a [pendingRef] received by [signUp], [signIn], [signUpOrIn] or [updateEmail].
  /// This function will only return an [AuthenticationResponse] successfully after the user
  /// presses the enchanted link in the authentication email.
  ///
  /// This function calls [checkForSession] periodically until the authentication
  /// is verified. It will keep polling even if it encounters network errors, but
  /// any other unexpected errors will be rethrown. If the [timeout] expires a
  /// `DescopeError.enchantedLinkExpired` error is thrown.
  /// [timeout] is an optional duration to poll for until giving up. If not
  /// given a default value of 2 minutes is used.
  ///
  /// To cancel it, you can wrap the response in a [CancelableOperation](https://pub.dev/documentation/async/latest/async/CancelableOperation-class.html).
  Future<AuthenticationResponse> pollForSession({required String pendingRef, Duration? timeout});
}

/// Authenticate a user using an OAuth provider.
///
/// Use the Descope console to configure which authentication provider you'd like to support.
///
/// It's recommended to use `flutter_web_auth` to perform the authentication.
/// For further reference see: [flutter_web_auth](https://pub.dev/packages/flutter_web_auth)
abstract class DescopeOAuth {
  /// Starts an OAuth redirect chain to authenticate a user.
  ///
  /// This function returns a URL to redirect to in order to
  /// authenticate the user against the chosen [provider].
  ///
  /// It's recommended to use `flutter_web_auth` to perform the authentication.
  ///
  /// - Important: Make sure a default OAuth redirect URL is configured
  ///     in the Descope console, or provided by this call via [redirectUrl].
  Future<String> start({required OAuthProvider provider, String? redirectUrl});

  /// Completes an OAuth redirect chain.
  ///
  /// This function exchanges the [code] received in the `code` URL
  /// parameter for an [AuthenticationResponse].
  Future<AuthenticationResponse> exchange({required String code});
}

/// Authenticate a user using SSO.
///
/// Use the Descope console to configure your SSO details in order for this method to work properly.
///
/// It's recommended to use `flutter_web_auth` to perform the authentication.
/// For further reference see: [flutter_web_auth](https://pub.dev/packages/flutter_web_auth)
abstract class DescopeSso {
  /// Starts an SSO redirect chain to authenticate a user.
  ///
  /// This function returns a URL to redirect to in order to
  /// authenticate the user according to the provided [emailOrTenantId].
  ///
  /// It's recommended to use `flutter_web_auth` to perform the authentication.
  ///
  /// - Important: Make sure a SSO is set up correctly and a redirect URL is configured
  ///     in the Descope console, or provided by this call via [redirectUrl].
  Future<String> start({required String emailOrTenantId, String? redirectUrl});

  /// Completes an SSO redirect chain.
  ///
  /// This function exchanges the [code] received in the `code` URL
  /// parameter for an [AuthenticationResponse].
  Future<AuthenticationResponse> exchange({required String code});
}
